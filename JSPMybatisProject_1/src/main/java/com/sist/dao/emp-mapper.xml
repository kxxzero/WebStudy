<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.sist.dao.emp-mapper">
	<!-- 
	SQL 문장 저장
		1. 	데이터를 받을 데이터형 설정 : resultType
		2. 	?에 들어가는 값을 설정 : parameterType
		3. 	VO에 값 요청 시
			column명이 다른 경우에는 설정
			vo의 변수 = column이 같은 경우
			
			예) 	class EmpVO{
					private int empno; => empno => setEmpno()
					private String name; => ename => serEname()
					
					select empno, ename as name // 컬럼명과 변수명이 다를 경우 별칭 부여 => 가급적 컬럼명과 변수명을 일치시키는 것이 좋음
						   setEmpno(), setName()
				}
			
		4. 	? 대신 사용 index
			${테이블명/컬럼}
			#{변수명} => ''
			
			예) 	String name="홍길동"
			
				WHERE name=${name}
				=> WHERE name=홍길동 // 오류 발생
				
				WHERE name=#{name}
				=> WHERE name='홍길동' // 자동 처리
				
				String table="emp"
				FROM #{table} => FROM 'emp' // 오류 발생
				
				FROM ${table} => FROM emp // 정상 처리
				
		==================================================> 기초
		5. 	동적 쿼리 => 수 많은 경우의 수를 한 번에 제어 가능 => forEach
		
			예) 	검색할 수 있는 경우의 수
				이름
				제목
				내용
				
				이름+제목
				이름+내용
				
				제목+내용
				
				이름+제목+내용
				
		6.	프로시저 호출
		==================================================> XML / Annotation
			XML + Annotation => Spring-Boot
			
			<select>
				SELECT ~
			</select>
			@Select("SELECT ~")
			
			*** 주의점 : 태그에 1개의 SQL 문장만 지정할 수 있음
				<select> : 데이터 검색
				<insert> : 데이터 추가
				<update> : 데이터 수정
				<delete> : 데이터 삭제
				<selectKey> : 자동 증가 번호
				<resultMap> : JOIN이 있는 경우 사용
				
					예) 	class EmpVO{
							private int empno;
							private String ename;
							private DeptVO dvo=new DepVO(); // 포함 클래스
						}
						
						class DeptVO{
							private String dname;
							private String loc;
						}
						SELECT empno, ename, dname, loc
						FROM emp, dept
						WHERE emp.deptno=dept.deptno
						
						<resultMap type="com.sist.dao.EmpVO">
							<result property="empno" column="empno"/>
							vo.setEmpno(rs.getInt(""))
							
							<result property="ename" column="ename"/>
							<result property="dvo.dname" column="dname"/>
							vo.setDname(rs.getString("dname"))
						</resultMap>
						
						while(rs.next()){
							EmpVO vo=new EmpVO();
							vo.setEmpno(rs.getInt("empno"))
							vo.setEname(rs.getString("ename")) // 2 대신 "ename"으로도 입력 가능
							vo.getDvo().setDname(rs.getString(3))
							vo.getDvo().setLoc(rs.getString(4))
						}
				<parameterMap> : 프로시저
				
			=>	<if>
				<forEach> : IN 연산자 IN ()
				<choose> : 다중 조건문
				<where> : 조건문
				<trim> : 제거
				
				WHERE
				<trim prefixOverride="OR">
					<if test="col=='name'"> // 컬럼명이 name이면
						name LIKE ...
					</if>
					
					<if test="col=='subject'">
						OR subject LIKE ...
					</if>
					
					<if test="col=='content'">
						OR content LIKE ...
					</if>
				</trim>
	 -->
	 
	 <!-- 
	 	as(alias 알리아스)
	 	1. 함수
	 	2. 컬럼명이 다른 경우 
	  -->
	 <select id="empListData" resultType="EmpVO">
	 	SELECT empno,ename,job,mgr,TO_CHAR(hiredate,'YYYY-MM-DD') as dbday,sal,comm,deptno FROM emp
	 </select>
	 
	 <resultMap type="com.sist.dao.EmpVO" id="empMap">
	 	<result property="dvo.dname" column="dname"/>
	 	<!-- vo.getDvo().setDname(rs.getString("dname")) -->
	 	<result property="dvo.loc" column="loc"/>
	 </resultMap>
	 
	 <sql id="select">
	 	SELECT empno,ename,job,TO_CHAR(hiredate,'YYYY-MM-DD') as dbday, sal,
	 </sql>
	 
	 <select id="empDeptJoinData" resultMap="empMap">
	 	<include refid="select"/>
	 	dname, loc
	 	FROM emp Join dept 
	 	ON emp.deptno=dept.deptno
	 </select>
	 
	 <select id="empDeptSubqueryData" resultMap="empMap">
	 	<include refid="select"/>
	 	(SELECT dname FROM dept WHERE deptno=emp.deptno) as dname,
	 	(SELECT loc FROM dept WHERE deptno=emp.deptno) as loc 
	 	FROM emp
	 </select>
	 
	 <!--
	 <select id="emp" resultType="EmpVO">
	 	SELECT * FROM emp
	 	WHERE sal&lt;3000 // '<' 특수문자 사용 시 오류 발생 
	 </select>
	 -->
	 
	 <select id="empNameData" resultType="string">
	 	<!-- 
	 		// "string" 또는 "java.lang.String"
	 		
	 		List<String> List<int>
	 		int => java.lang.Integer
	 	 -->
	 	 
	 	 SELECT ename FROM emp
	 </select>
	 
	 <select id="empFindData" resultType="EmpVO" parameterType="hashmap">
	 	SELECT empno,ename,job,TO_CHAR(hiredate,'YYYY-MM-DD') as dbday,sal
	    FROM emp
	    WHERE ename IN
	    <!-- <trim prefix="WHERE ename IN("> -->
	      <foreach collection="names" item="name" open="(" close=")" separator=",">
	       #{name}
	      </foreach>
	    <!-- </trim> -->
	 </select>
</mapper>